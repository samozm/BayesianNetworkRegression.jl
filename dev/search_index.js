var documenterSearchIndex = {"docs":
[{"location":"man/fit_model/#Fitting-the-Model","page":"Model Fitting","title":"Fitting the Model","text":"","category":"section"},{"location":"man/fit_model/#Network-Estimation","page":"Model Fitting","title":"Network Estimation","text":"","category":"section"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"BayesianNetworkRegression implements the statistical inference method for [Ozminkowski & Solís-Lemus 2022]","category":"page"},{"location":"man/fit_model/#Using-Matrix-style-input","page":"Model Fitting","title":"Using Matrix-style input","text":"","category":"section"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"After Input Data, we can estimate the network using the input data matrix_networks. ","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"We first load the data and split it into the covariate matrix and the response vector","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"using Distributed\naddprocs(2)\n\n@everywhere begin\n    using BayesianNetworkRegression,CSV,DataFrames,StaticArrays\n\n    matrix_networks = joinpath(dirname(pathof(BayesianNetworkRegression)), \"..\",\"examples\",\"matrix_networks.csv\")\n    data_in = DataFrame(CSV.File(matrix_networks))\n\n    X = Matrix(data_in[:,names(data_in,Not(\"y\"))])\n    y = Vector{Float64}(data_in[:,:y])\nend","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"Then we decide what the dimensionality of the latent node space (R) should be. Quality of inference will increase with increasing dimensionality up to a point, after which it will approximately plateau. The time it takes to fit the model will increase (worse than linearly) with increasing dimensionality. For our simulations, R=7 worked best. ","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"We will run the model with 20000 burn-in followed by 10000 retained samples. This will likely not be enough to achieve convergence (but the form of the results will be the same).","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"result = Fit!(X, y, 7, # we set R=7\n    nburn=20000, nsamples=10000, x_transform=false, # x_transform=false indicates we're inputting the data in Matrix-style, it doesn't need to be re-organized\n    num_chains=2, # we'll run two chains, allowing us to check for convergence\n    seed=1234, # we'll set a random seed for reproducibility\n    in_seq=false # if we did not want to use parallelization, there is an option to run the chains in sequence\n    )","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"***Note: a progress-meter is utilized to keep you informed of the estimated completion time, but when parallelization is used updating it is very costly so it is only updated sporadically.*** ","category":"page"},{"location":"man/fit_model/#Using-Vector-style-input","page":"Model Fitting","title":"Using Vector-style input","text":"","category":"section"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"After Input Data, we can estimate the network using the input data vector_networks and vector_response. ","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"We first load the data and split it into the covariate matrix and the response vector","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"using Distributed\naddprocs(2)\n\n@everywhere begin\n    using BayesianNetworkRegression,JLD2,DataFrames,StaticArrays\n\n    vector_networks = JLD2.load(joinpath(dirname(pathof(BayesianNetworkRegression)), \"..\",\"examples\",\"vector_networks.jld2\"))\n    vector_response = JLD2.load(joinpath(dirname(pathof(BayesianNetworkRegression)), \"..\",\"examples\",\"vector_response.jld2\"))\n\n    X = vector_networks[\"networks\"]\n    y = vector_response[\"response\"]\nend","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"Then we decide what the dimensionality of the latent node space (R) should be. Quality of inference will increase with increasing dimensionality up to a point, after which it will approximately plateau. The time it takes to fit the model will increase (worse than linearly) with increasing dimensionality. For our simulations, R=7 worked best. ","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"We will run the model with 20000 burn-in followed by 10000 retained samples. This will likely not be enough to achieve convergence (but the form of the results will be the same).","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"result = Fit!(X, y, 7, # we set R=7\n    nburn=20000, nsamples=10000, x_transform=true, # x_transform=true indicates we're inputting the data in Vector-style, it needs to be re-organized\n    num_chains=2, # we'll run two chains, allowing us to check for convergence\n    seed=1234, # we'll set a random seed for reproducibility\n    in_seq=false # if we did not want to use parallelization, there is an option to run the chains in sequence\n    )","category":"page"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"***Note: a progress-meter is utilized to keep you informed of the estimated completion time, but when parallelization is used updating it is very costly so it is only updated sporadically.*** ","category":"page"},{"location":"man/fit_model/#Error-reporting","page":"Model Fitting","title":"Error reporting","text":"","category":"section"},{"location":"man/fit_model/","page":"Model Fitting","title":"Model Fitting","text":"Please report any bugs and errors by opening an issue.","category":"page"},{"location":"man/interpretation/#Interpreting-the-Model-Results","page":"Interpretation","title":"Interpreting the Model Results","text":"","category":"section"},{"location":"man/interpretation/#Result-format","page":"Interpretation","title":"Result format","text":"","category":"section"},{"location":"man/interpretation/","page":"Interpretation","title":"Interpretation","text":"The Fit! function will return a Results object with the following members:","category":"page"},{"location":"man/interpretation/","page":"Interpretation","title":"Interpretation","text":"state\nrhat","category":"page"},{"location":"man/interpretation/#State","page":"Interpretation","title":"State","text":"","category":"section"},{"location":"man/interpretation/","page":"Interpretation","title":"Interpretation","text":"result.state contains the (post-burn-in) outputs of the sampling algorithm, with focus on the following two variables","category":"page"},{"location":"man/interpretation/","page":"Interpretation","title":"Interpretation","text":"xi\n: a vector describing whether each node (microbe) is influential on the response. Set to 1 if the microbe is influential and 0 if it is not. \ngamma\n: a vector of coefficients describing the effect of each edge (relationship) on the response. ","category":"page"},{"location":"man/interpretation/#\\hat{R}","page":"Interpretation","title":"hatR","text":"","category":"section"},{"location":"man/interpretation/","page":"Interpretation","title":"Interpretation","text":"result.rhat contains r-hat statistics (Vehtari et al. 2020), which are used to assess whether the sampling algorithm has converged. Values close to 1 indicate convergence (Vehtari et al. suggest using a cutoff of hatR  101 to indicate convergence). Values are provided for all xi and gamma variables.","category":"page"},{"location":"man/interpretation/#Interpretation","page":"Interpretation","title":"Interpretation","text":"","category":"section"},{"location":"man/interpretation/#State-2","page":"Interpretation","title":"State","text":"","category":"section"},{"location":"man/interpretation/","page":"Interpretation","title":"Interpretation","text":"To aid in interpretation of results, run the following (in julia):","category":"page"},{"location":"man/interpretation/","page":"Interpretation","title":"Interpretation","text":"using Statistics\nmean(result.state.ξ[:,:],dims=1)\nmean(result.state.γ[:,:],dims=1)","category":"page"},{"location":"man/interpretation/","page":"Interpretation","title":"Interpretation","text":"The first mean calculates the posterior probability that each node is influential.  The second mean calculates the point-estimate for the coefficients.","category":"page"},{"location":"man/interpretation/","page":"Interpretation","title":"Interpretation","text":"In order to generate (95\\%) credible intervals for the coefficients, the following can be run. nsamp should be the number of post-burn-in samples.","category":"page"},{"location":"man/interpretation/","page":"Interpretation","title":"Interpretation","text":"using DataFrames\n\nnsamp = 10000\nγ_sorted = sort(result.γ,dims=1)\nlw = convert(Int64, round(nsamp * 0.025))\nhi = convert(Int64, round(nsamp * 0.975))\n\nDataFrame(L=γ_sorted[lw,:,1],U=γ_sorted[hi,:,1])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fit!(X::AbstractArray{T,2}, y::AbstractVector{U}, R; η=1.01,ζ=1.0,ι=1.0,aΔ=1.0,bΔ=1.0, ν=10, nburn=30000, nsamples=20000, V=0, x_transform=true, suppress_timer=false, num_chains=2, seed=nothing, in_seq=false, full_results=false, purge_burn=nothing) where {T,U}","category":"page"},{"location":"#BayesianNetworkRegression.Fit!-Union{Tuple{U}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{U}, Any}} where {T, U}","page":"Home","title":"BayesianNetworkRegression.Fit!","text":"Fit!(X::AbstractArray{T}, y::AbstractVector{U}, R; η=1.01,ζ=1.0,ι=1.0,aΔ=1.0,bΔ=1.0, \n     ν=10, nburn=30000, nsamples=20000, V=0, x_transform=true, suppress_timer=false, num_chains=2, seed=nothing, \n     in_seq=false, full_results=false, purge_burn=nothing) where {T,U}\n\nFit the Bayesian Network Regression model, generating nsamples Gibbs samples after nburn burn-in are discarded\n\nArguments\n\nX: matrix, required, matrix of unweighted symmetric adjacency matrices to be used as predictors. Two options:        2D matrix with each row the upper triangle of the adjacency matrix associated with one sample       1D matrix with each row the adjacency matrix relating the nodes to one another\ny: vector, required, vector of response variables\nR: integer, required, the dimensionality of the latent variables u, a hyperparameter\nη: float, default=1.01, hyperparameter used for sampling the 0 value of the πᵥ parameter, must be > 1\nζ: float, default=1.0, hyperparameter used for sampling θ\nι: float, default=1.0, hyperparameter used for sampling θ\naΔ: float, default=1.0, hyperparameter used for sampling Δ\nbΔ: float, default=1.0, hyperparameter used for sampling Δ \nν: integer, default=10, hyperparameter used for sampling M, must be > R\nnburn: integer, default=30000, number of burn-in samples to generate and discard\nnsamples: integer, default=20000, number of Gibbs samples to generate after burn-in\nV: integer, default=0, dimensionality of the adjacency matrices (number of nodes)\nx_transform: boolean, default=true, set to false if X has been pre-transformed into one row per sample. Otherwise the X will be transformed automatically.\nsuppress_timer: boolean, default=false, set to true to suppress \"progress meter\" output\nnum_chains: integer, default=2, number of separate sampling chains to run (for checking convergence)\nseed: integer, default=nothing, random seed used for repeatability\nin_seq: boolean, default=false, set to true to run multiple chains in sequence. Otherwise multiple chains will be run in parallel. (for performance reasons should be set to false if only one chain is used)\nfull_results: boolean, default=false, set to true to return full post-burn-in chains for relevant variables\npurge_burn: integer, default=nothing, if set must be less than the number of burn-in samples (and ideally burn-in is a multiple of this value). After how many burn-in samples to delete previous burn-in samples.\n\nReturns\n\nEither the entire state table with post-burn-in samples of relevant variables (ξ, γ, μ, τ²) or a Results object with the state table from the first chain and PSRF r-hat values for  γ and ξ (depending on the value of full_results)\n\n\n\n\n\n","category":"method"},{"location":"man/inputdata/#Input-for-BayesianNetworkRegression","page":"Input Data","title":"Input for BayesianNetworkRegression","text":"","category":"section"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"BayesianNetworkRegression is the main method implemented in the package, to estimate the relationships between the edges of the microbiome network and the variable of interest.  The variable of interest should be a vector of real numbers. There are two alternatives for the network input data:","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"A vector of networks, where each item in the vector (of length n, where n is the samplesize) is an m \\times m adjacency matrix describing the network. All adjacency matrices must be the same size.\nA n \\times m(m-1)/2 matrix, where each row in the matrix is the upper triangle of the adjacency matrix describing the network for that sample.","category":"page"},{"location":"man/inputdata/#Tutorial-data:-Matrix-format","page":"Input Data","title":"Tutorial data: Matrix format","text":"","category":"section"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"We suggest that you create a special directory for running these examples, where input files can be downloaded and where output files will be created (with estimated networks for instance). Enter this directory and run Julia from there.","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"Suppose you have a file with n rows and m(m-1)/2 + 1 columns. For each row, the first m(m-1)/2 columns describe the upper triangle of an adjacency matrix and the last gives the response variable.  You can access the example file of input networks (and response) here","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"Do not copy-paste into a \"smart\" text-editor. Instead, save the file directly into your working directory using \"save link as\" or \"download linked file as\". This file contains 100 adjacency matrices and corresponding responses.","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"If matrix_networks.csv is in your working directory, you can view its content within Julia:","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"less(\"matrix_networks.csv\")","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"or like this, to view the version downloaded with the package:","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"matrix_networks = joinpath(dirname(pathof(BayesianNetworkRegression)), \"..\",\"examples\",\"matrix_networks.csv\")\nless(matrix_networks)","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"Just type q to quit viewing this file.","category":"page"},{"location":"man/inputdata/#Tutorial-data:-Vector-format","page":"Input Data","title":"Tutorial data: Vector format","text":"","category":"section"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"We suggest that you create a special directory for running these examples, where input files can be downloaded and where output files will be created (with estimated networks for instance). Enter this directory and run Julia from there.","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"For this data format, we will utilize the JLD2 package, which handles julia formatting.","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"Suppose you have two files, one containing a vector of adjacency matrices and the other a vector of responses (real numbers). You can access the example files for the networks  here and for the responses here","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"To load the data and view an example in julia do the following:","category":"page"},{"location":"man/inputdata/","page":"Input Data","title":"Input Data","text":"using JLD2\nvector_networks = JLD2.load(\"vector_networks.jld2\")\nvector_response = JLD2.load(\"vector_response.jld2\")\n\nvector_networks[\"networks\"][1] # shows the first adjancency matrix\nvector_response[\"response\"] # shows all responses","category":"page"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/#Installation-of-Julia","page":"Installation","title":"Installation of Julia","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Julia is a high-level and interactive programming language (like R or Matlab), but it is also high-performance (like C). To install Julia, follow instructions here. For a quick & basic tutorial on Julia, see learn x in y minutes.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Editors:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Visual Studio Code provides an editor and an integrated development environment (IDE) for Julia: highly recommended!\nyou can also run Julia within a Jupyter notebook (formerly IPython notebook).","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"IMPORTANT: Julia code is just-in-time compiled. This means that the first time you run a function, it will be compiled at that moment. So, please be patient! Future calls to the function will be much much faster. Trying out toy examples for the first calls is a good idea.","category":"page"},{"location":"man/installation/#Installation-of-the-package-PhyloNetworks","page":"Installation","title":"Installation of the package PhyloNetworks","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To install the package, ","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Clone BayesianNetworkRegression.jl to your local machine.\ntype inside Julia:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"]\ndev PATH/BayesianNetworkRegression.jl","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"where PATH is the path to the BayesianNetworkRegression.jl depository on your machine.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The first step can take a few minutes, be patient.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"The BayesianNetworkRegression package has dependencies like Distributions and DataFrames (see the Project.toml file for the full list), but everything is installed automatically.","category":"page"},{"location":"man/installation/#Loading-the-Package","page":"Installation","title":"Loading the Package","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To check that your installation worked, type this in Julia to load the package. This is something to type every time you start a Julia session:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"using BayesianNetworkRegression;","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"This step can also take a while, if Julia needs to pre-compile the code (after a package update for instance).","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"You can see a list of all the functions with","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"varinfo(BayesianNetworkRegression)","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"and press ? inside Julia to switch to help mode, followed by the name of a function (or type) to get more details about it.","category":"page"}]
}
